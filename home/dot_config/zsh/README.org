#+author: Yuriy Artemyev
#+email:  anuvyklack@gmail.com
#+startup: overview
#+auto_tangle: t

This is a configuration file for the [[https://www.zsh.org/][Z shell]] written as an [[https://orgmode.org/][Org]] document in the
[[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] paradigm. To compile it open [[https://www.gnu.org/software/emacs/][Emacs]] (of some how modern
version) press =Alt + x= type =org-babel-tangle= and press =Enter=. This will produce
zsh config files.

* Zsh configuration files

Zsh has several system-wide and user-local configuration files.

System-wide configuration files are by default stored in =/etc= directory.

User-local configuration files have the same name as their global counterparts
but are prefixed with a dot (so hidden). Zsh looks for these files in the path
stored in the ~$ZDOTDIR~ environment variable. If said variable is not defined,
Zsh will use the user's home directory.

The configuration files are read in the following order:
  1. =/etc/zshenv=
  2. =~/.zshenv=
  3. =/etc/zprofile=
  4. =~/.zprofile=
  5. =/etc/zshrc=
  6. =~/.zshrc=
  7. =/etc/zlogin=
  8. =~/.zlogin=
  9. =/etc/zlogout=
  10. =~/.zlogout=

** How I choose where to put a setting

- if it is needed by a command run non-interactively: =.zshenv=
- if it should be updated on each new shell: =.zshenv=
- if it runs a command which may take some time to complete: =.zprofile=
- if it is related to interactive usage: =.zshrc=
- if it is a command to be run when the shell is fully setup: =.zlogin=
- if it releases a resource acquired at login: =.zlogout=

* zshenv
:PROPERTIES:
:header-args: :tangle (file-name-concat (getenv "ZDOTDIR") ".zshenv")
:END:
** Description
*Read every time*

This file is always sourced, so it should set environment variables which need
to be updated frequently.  `$PATH` (or its associated counterpart path) is
a good example because you probably don't want to restart your whole session to
make it update.  By setting it in that file, reopening a terminal emulator will
start a new Zsh instance with the PATH value updated.

But be aware that this file is read even when Zsh is launched to run a single
command (with the -c option), even by another tool like make, and thus, it
should be kept as small as possible.  You should be very careful to not modify
the default behavior of standard commands because it may break some tools (by
setting aliases for example).

** Preamble
#+begin_src sh
#!/usr/bin/env zsh
#                     ██
#                    ░██
#      ██████  ██████░██████   █████  ██████  ██    ██
#     ░░░░██  ██░░░░ ░██░░░██ ██░░░██░██░░░██░██   ░██
#        ██  ░░█████ ░██  ░██░███████░██  ░██░░██ ░██
#       ██    ░░░░░██░██  ░██░██░░░░ ░██  ░██ ░░████
#  ██  ██████ ██████ ░██  ░██░░█████ ░██  ░██  ░░██
# ░░  ░░░░░░ ░░░░░░  ░░   ░░  ░░░░░  ░░   ░░    ░░
#
# This file was automatically generated by Emacs Org-Mode `org-babel-tangle'.
# Do not change this file. The main file is `README.org`.
#+end_src

** Code
For WSL
 #+begin_src sh
[[ "$(umask)" = "000" ]] && umask 022
 #+end_src

#+begin_src sh
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
export XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
export XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
export XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
#+end_src

Make zsh to search my config files in ~$XDG_CONFIG_HOME~ directory:
zsh looks for user local config files in the path stored in the ~$ZDOTDIR~
environment variable. If said variable is not defined, Zsh will use the user's
home directory.
#+begin_src sh
export ZDOTDIR="$XDG_CONFIG_HOME/zsh"
#+end_src

On Ubuntu the ~compinit~ function is called in =/etc/zsh/zshrc=. We want to disable
this behavior according to the comment in that file. ([[https://blog.patshead.com/2011/04/improve-your-oh-my-zsh-startup-time-maybe.html][Source]])
#+begin_src sh
# skip_global_compinit=1
#+end_src

Ensure that a non-login, non-interactive shell has a defined environment. ([[https://github.com/sorin-ionescu/prezto/blob/master/runcoms/zshenv][Source]])
#+begin_src sh
if [[ ( "$SHLVL" -eq 1 && ! -o LOGIN ) && -s "$ZDOTDIR/.zprofile" ]]; then
  source "$ZDOTDIR/.zprofile"
fi
#+end_src

* zprofile
:PROPERTIES:
:header-args: :tangle (file-name-concat (getenv "ZDOTDIR") ".zprofile")
:END:
** Description
*Read at login*

This file was added for [[http://www.kornshell.com][KornShell]] fans. You may treat that file like =.zshenv=
but for commands and variables which should be set once or which don't need to
be updated frequently:

 - environment variables to configure tools
   (flags for compilation, data folder location, etc.)

 - configuration which execute commands as it may take some time to execute.
   (like ~SCONSFLAGS="--jobs=$(( $(nproc) 1))"~)

If you modify this file, you can apply the configuration updates by running
a login shell:

#+begin_src sh :tangle no
exec zsh --login
#+end_src

** Preamble
#+begin_src sh
#!/usr/bin/env zsh
#                                       ███ ██ ███
#                                      ██░ ░░ ░░██
#      ██████ ██████  ██████  █████   ░██   ██ ░██   █████
#     ░░░░██ ░██░░░██░░██░░█ ██░░░██ ██████░██ ░██  ██░░░██
#        ██  ░██  ░██ ░██ ░ ░██  ░██░░░██░ ░██ ░██ ░███████
#       ██   ░██████  ░██   ░██  ░██  ░██  ░██ ░██ ░██░░░░
#  ██  ██████░██░░░   ███   ░░█████   ░██  ░██ ░██ ░░█████
# ░░  ░░░░░░ ░██     ░░░     ░░░░░    ░░   ░░  ░░   ░░░░░
#            ░░
#
# Executes commands at login pre-zshrc.
# This file was automatically generated by Emacs Org-Mode `org-babel-tangle'.
# Do not change this file. The main file is `README.org`.
#+end_src

** WORDCHARS
Non-alphanumeric chars treated as part of a word.
You can tweak this if you'd prefer ^w to break on dot, underscore, etc.
#+begin_src sh
export WORDCHARS='*?[]~=&;!#$%^(){}<>'
#+end_src

** WSL

- ~$IS_WSL~ environment variable existed in the WSL 1 version.
- ~$WSL_DISTRO_NAME~ variable exists in the WSL 2 version.
- =-n= :: true if length of string is non-zero.
#+begin_src sh
if [[ -n "$IS_WSL" || -n "$WSL_DISTRO_NAME" ]];
then  # We are in wsl.
  export WINDOWS_HOST_IP=$(awk '/nameserver/ {print $2}' /etc/resolv.conf)
  export WINDOWS_USER="$(cmd.exe /C "echo %USERNAME%" 2>/dev/null | tr -d '\r')"
fi
#+end_src

** My Variables
#+begin_src sh
export DOTFILES="$HOME/dotfiles"
export SOFTWARE="$HOME/soft"
export STOW_DIR="/usr/local/stow"
export LOCAL_STOW_DIR="$HOME/.local/stow"
#+end_src

For scoping purposes, anonymous functions can be used. They will be
automatically executed and then thrown away.
#+begin_src sh
() {
  local DIRS=($SOFTWARE $LOCAL_STOW_DIR)
  for local DIR in $DIRS; do
    if [[ ! -d $DIR ]]; then
      mkdir -p $DIR
    fi
  done
}
#+end_src

** Path
Ensure path arrays do not contain duplicates.
#+begin_src sh
typeset -gU cdpath fpath mailpath path
#+end_src

Set the list of directories that Zsh searches for programs.
#+begin_src sh
path+=(
  /usr/local/{bin,sbin}
  /opt/visit/bin
  /opt/ParaView-5.8.1/bin
  $HOME/.emacs.d/bin
  $HOME/.spoof-dpi/bin  # https://github.com/xvzc/SpoofDPI
)
#+end_src

Set the list of directories that cd searches.
#+begin_src sh
# cdpath=(
#   $HOME/.config
#   $cdpath
# )
#+end_src

** Homebrew
#+begin_src sh
if whence /home/linuxbrew/.linuxbrew/bin/brew > /dev/null 2>&1; then
  local BREWCACHE="$HOME/.cache/Homebrew/brewenv.zsh"

  if [[ ! -s $BREWCACHE(#q.md-7N) ]]; then
    /home/linuxbrew/.linuxbrew/bin/brew shellenv > $BREWCACHE 2> /dev/null
  fi
  source $BREWCACHE

  # Enable completion for brew and programs installes with brew.
  FPATH=$(brew --prefix)/share/zsh/site-functions:$FPATH
fi
#+end_src

** Editors
#+begin_src sh
# export EDITOR VISUAL
if (( $+commands[nvim] )); then
  export EDITOR='nvim'
  export VISUAL="$EDITOR"
  export DIFFPROG='nvim -d'
else
  export EDITOR='vim'
fi

export PAGER='less -R'
#+end_src

** COMMENT Browser
#+begin_src sh
if [[ -f /opt/vivaldi/vivaldi ]]; then
  export BROWSER='/opt/vivaldi/vivaldi'
fi
#+end_src

** COMMENT Language
#+begin_src sh
if [[ -z "$LANG" ]]; then
    export LANG='en_US.UTF-8'
    export LANGUAGE=en_US.UTF-8
fi
#+end_src

** Man
The width of the text column in the man.
#+begin_src sh
export MANWIDTH=80
#+end_src

Tie together the scalar =$MANPATH= and the array =$manpath= in the same way that
=$PATH= and =$path= ties and ensure array do not contain duplicates.
#+begin_src sh
typeset -T MANPATH manpath
typeset -gU manpath
#+end_src

Generate =$MANPATH= from the output of the ~manpath~ command
#+begin_src sh
# export MANPATH=$(command manpath)
#+end_src

Use [[https://github.com/sharkdp/bat][bat]] as a colorizing pager for =man=
#+begin_src sh
# export MANPAGER="sh -c 'col -bx | bat -l man -p'"
#+end_src

** Less

Set the default Less options. Mouse-wheel scrolling has been disabled =-X= and =-F=
(exit if the content fits on one screen) to enable it.

- =-F= :: Exit if the content fits on one screen
- =-g= :: Highlights just the current match of any searched string.
- =-i= :: Case-insensitive searches.
- =-M= :: Shows more detailed prompt, including file position.
- =-N= :: Shows line numbers (useful for source code viewing).
- =-R= / =--RAW-CONTROL-CHARS= ::
- =-S= :: Disables line wrap ("chop long lines"). Long lines can be seen by side scrolling.
- =-X= :: Leave file contents on screen when less exits.
- =-?= :: Shows help.
- =+F= :: Follow mode for log.
- =-w= / =--hilite-unread= ::
        Temporarily highlights the first "new" line after a forward movement of
        a full page.
- =-z-4= :: Move page not on the full high of the screen but on high minus 4 lines

#+begin_src sh
# export LESS='-F -i -M -R -S -w -z-3'
# export LESS='-F -i -M -R -S -z-3'
export LESS='-i -M -R -S -z-3'
#+end_src

Set the Less input preprocessor. Try both =lesspipe= and =lesspipe.sh= as either
might exist on a system.
#+begin_src sh
if (( $#commands[(i)lesspipe(|.sh)] )); then
  export LESSOPEN="| /usr/bin/env $commands[(i)lesspipe(|.sh)] %s 2>&-"
fi
#+end_src

#+begin_src sh
export LESSHISTFILE="$HOME/.cache/lesshst"
#+end_src

** Colored man pages

#+begin_src sh
# export LESS_TERMCAP_mb=$'\e[01;31m'     # Begins blinking.
export LESS_TERMCAP_md=$'\e[01;97m'     # Begins bold.
export LESS_TERMCAP_so=$'\e[00;47;30m'  # Begins standout-mode.
export LESS_TERMCAP_us=$'\e[04;97m'     # Begins underline.
export LESS_TERMCAP_me=$'\e[0m'         # Ends mode.
export LESS_TERMCAP_se=$'\e[0m'         # Ends standout-mode.
export LESS_TERMCAP_ue=$'\e[0m'         # Ends underline.
#+end_src

** ~LS_COLORS~
Specification:

  #+begin_src sh :tangle no
  LS_COLORS='di=1:fi=0:...:or=31:*.deb=90'
  #+end_src

The ~*.deb=90~ parameter above tells =ls= to display any files ending with a ~.deb~
extension using the color specified, 90 or dark grey in this case. This can be
applied to any types of files (eg. you could use ~*.jpg=33~ to make JPEG files
appear orange).

The ~$LS_COLORS~ variable aldo used to color the zsh comletions.

Tie together the scalar ~$LS_COLORS~ and the array ~$ls_colors~ in the same way
that ~$PATH~ and ~$path~ ties.
#+begin_src sh
typeset -T LS_COLORS ls_colors
#+end_src

Here the ~;~ chars need to be escaped by ~\~ (for example: ~di=1\;36~), other
way they somewhy will be converted to ~:~ chars. Or it is also work to
enclose them in quotes.
#+begin_src sh
export ls_colors=(
  'di=1;36'   # Directory : bold; cyan
  'fi=0'      # File : default
  'ln=35'     # Symbolic Link : purple
  'pi=33'     # Fifo file
  'so=32'     # Socket file
  'bd=30;46'  # Block (buffered) special file : black; cyan background
  'cd=34;43'  # Character (unbuffered) special file
  # 'or'        # (ORPHAN) Symbolic link pointing to an orphaned non-existent file
  # 'mi'        # Non-existent file pointed to by a symbolic link (visible when you type ls -l)
  'su=30;41'  # File that is setuid (u+s)
  'sg=30;46'  # File that is setgid (g+s)
  'tw=30;42'  # Directory that is sticky and other-writable (+t,o+w)
  'ow=30;43'  # Directory that is other-writable (o+w) and not sticky
  'ex=31'     # File which is executable (ie. has ‘x’ set in permissions).
)
#+end_src

** Info
Tie together the scalar ~$INFOPATH~ and the array ~$infopath~
in the same way that ~$PATH~ and ~$path~ ties.
#+begin_src sh
typeset -T INFOPATH infopath
#+end_src

Ensure array do not contain duplicates.
#+begin_src sh
typeset -gU infopath
#+end_src

#+begin_src sh
infopath+=(
  /usr/share/info/
  $HOME/.nix-profile/share/info
)
#+end_src

** Bat
#+begin_src sh
if (( $+commands[bat] )); then
  export BAT_PAGER="less ${LESS}"
  # export BAT_PAGER="less -RF"
fi
#+end_src

** CMake options
#+begin_src sh
if (( $+commands[cmake] )); then
  export CMAKE_BUILD_PARALLEL_LEVEL=15
fi
#+end_src

** Home-manager
#+begin_src sh
if (( $+commands[home-manager] )); then
  source $HOME/.nix-profile/etc/profile.d/hm-session-vars.sh
fi
#+end_src
** Emacs
Use ~plists~ for deserialization
#+begin_src sh
export LSP_USE_PLISTS=true
#+end_src

** Par (paragraph formating)
This config is recommended in par man.
#+begin_src sh
export PARINIT="rTbgqR B=.,?'_A_a_@ Q=_s>|"
#+end_src

** Ripgrep
#+begin_src sh
if (( $+commands[rg] )); then
  export RIPGREP_CONFIG_PATH="$HOME/.config/rg/config"
fi
#+end_src

** COMMENT XDG
#+begin_src sh
export XDG_RUNTIME_DIR="/tmp/runtime-$USER"
#+end_src

** COMMENT pkg-config
Create parameter and array and tie them together in the manner
of ~$PATH~ and ~$path~.
#+begin_src sh
typeset -T -gU PKG_CONFIG_PATH pkg_config_path
export PKG_CONFIG_PATH
#+end_src

#+begin_src sh
pkg_config_path=(
    /usr/lib/pkgconfig
    /usr/lib/x86_64-linux-gnu/pkgconfig
    /usr/share/pkgconfig
    /opt/petsc-real/lib/pkgconfig
    /opt/slepc-real/lib/pkgconfig
)
#+end_src

** COMMENT Golang
#+begin_src sh
export GOPATH=$HOME/code/go
#+end_src

** COMMENT PuDB (Python debugger)
Set ~breakpoint()~ in Python to call pudb.
#+begin_src sh
export PYTHONBREAKPOINT="pudb.set_trace"
#+end_src

** COMMENT Intel-MKL
#+begin_src sh
if [[ -s /opt/intel/mkl/bin/mklvars.sh ]]; then
    source /opt/intel/mkl/bin/mklvars.sh intel64
    export MKL_THREADING_LAYER=GNU
fi
#+end_src

#+begin_src sh
if [[ -s /etc/profile.d/modules.sh ]]; then
  source /etc/profile.d/modules.sh
fi
#+end_src

** COMMENT Guix
#+begin_src sh
export GUIX_LOCPATH="$HOME/.guix-profile/lib/locale"
# Add Guix to $PATH.
GUIX_PROFILE="$HOME/.config/guix/current"
. "$GUIX_PROFILE/etc/profile"
#+end_src

** COMMENT Libraries
#+begin_src sh
# export PETSC_DIR=`pwd`
# export PETSC_ARCH=""
# export SLEPC_DIR=~/src/slepc-3.14.2
# export DEAL_II_DIR=~/software/dealii-9.3.0/build
#+end_src

** COMMENT Manualy compiled Neovim
#+begin_src sh
export PATH="$HOME/neovim/bin:$PATH"
#+end_src

** QT Applications
#+begin_src sh
if [[ $XDG_SESSION_TYPE == 'wayland' ]]; then
    export QT_QPA_PLATFORM=wayland
fi
export QT_AUTO_SCREEN_SCALE_FACTOR=1
#+end_src

** Tensorflow
#+begin_src sh
# export TENSORFLOW="$HOME/.local/lib/python3.11/site-packages/tensorflow:$PATH"
# export TENSORFLOW_PATH="$HOME/.local/lib/python3.11/site-packages/tensorflow"
export TENSORFLOW_PATH="$HOME/.local/lib/python3.11/site-packages"
#+end_src

** Footer
#+begin_src sh
# vim: ft=zsh tw=80 ts=2 sw=2
#+end_src

* zshrc
:PROPERTIES:
:header-args: :tangle (file-name-concat (getenv "ZDOTDIR") ".zshrc")
:END:
** Description

*Read when interactive*

It is a good practise to put here everything needed only for interactive usage:
  - prompt
  - command completion
  - command correction
  - command suggestion
  - command highlighting
  - output coloring
  - aliases
  - key bindings
  - commands history management
  - other miscellaneous interactive tools (=auto_cd=, =manydots-magic=)

** Preamble
#+begin_src sh
#!/usr/bin/env zsh
#                     ██
#                    ░██
#      ██████  ██████░██████  ██████  █████
#     ░░░░██  ██░░░░ ░██░░░██░░██░░█ ██░░░██
#        ██  ░░█████ ░██  ░██ ░██ ░ ░██  ░░
#       ██    ░░░░░██░██  ░██ ░██   ░██   ██
#  ██  ██████ ██████ ░██  ░██░███   ░░█████
# ░░  ░░░░░░ ░░░░░░  ░░   ░░ ░░░     ░░░░░

# This file was automatically generated by Emacs Org-Mode `org-babel-tangle'.
# Do not change this file. The main file is `README.org`.
#+end_src

** My functions
Setting autoloaded functions from my local library. I load them here because use
~color~ function later to style the output.
#+begin_src sh
local my_zsh_functions=${ZDOTDIR}/functions
fpath+=($my_zsh_functions)
if [[ -d "$my_zsh_functions" ]]; then
  autoload -Uz $(command ls $my_zsh_functions)
fi
#+end_src

** COMMENT Install missing programs with =bin= package manager
#+begin_src sh
install_missing_programs
#+end_src

** Powerlevel10k instant prompt

Enable Powerlevel10k instant prompt. Should stay close to the top of
=~/.config/zsh/.zshrc=.  Initialization code that may require console input
(password prompts, [y/n] confirmations, etc.) must go above this block,
everything else may go below.
#+begin_src sh
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]
then
  # Suppress the warining about console output during zsh initialization.
  typeset -g POWERLEVEL9K_INSTANT_PROMPT=quiet
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi
#+end_src

** Plugin manager invocation

#+begin_src sh
declare -A ZNAP  # Create an associative array.
ZNAP[PLUGINS]="$HOME/.local/share/zsh/plugins"
ZNAP[SELF]="$ZNAP[PLUGINS]/zsh-snap"
ZNAP[BIN]="$ZNAP[SELF]/znap.zsh"
#+end_src

Clone =znap=.
#+begin_src sh
if [[ ! -s $ZNAP[BIN] ]]; then
  git clone 'https://github.com/marlonrichert/zsh-snap.git' $ZNAP[SELF]
fi
source $ZNAP[BIN]
#+end_src

#+begin_src sh
# zstyle ':znap:*' auto-compile no
#+end_src

Do not auto compile functions in my folder, because I compile them later into
one library file.
#+begin_src sh
zstyle ':znap:*' auto-compile-ignore "${my_zsh_functions}/*"
#+end_src

** Prompt
#+begin_src sh
THEME=powerlevel10k
# THEME=geometry
#+end_src

#+begin_src sh
case $THEME in
  powerlevel10k)
    [[ -f ~/.config/zsh/themes/p10k.zsh ]] &&
      source ~/.config/zsh/themes/p10k.zsh

    znap source romkatv/powerlevel10k
    ;;
  geometry)
    # https://github.com/geometry-zsh/geometry
    GEOMETRY_COLOR_DIR=152

    # GEOMETRY_PROMPT=(geometry_status geometry_path) # redefine left prompt
    # GEOMETRY_RPROMPT+=(geometry_exec_time pwd)      # append exec_time and pwd right prompt

    znap prompt geometry-zsh/geometry
    ;;
esac
unset THEME
#+end_src

#+begin_src sh
# # PROMPT_TITLE='$USER@$HOST $PWD'  # default
#
# # Полный путь до текущей директории. Подстроку эквивалентную `$HOME`
# # заменяем на тильду. Ковычки дожны быть одинарными. С двойными заголовок
# # не обновляется при смене директории.
# # PROMPT_TITLE='${PWD/#${HOME}/~}'
#+end_src

#+begin_src sh
# PROMPT_TITLE=''
#+end_src

** Terminal title
Heavy inspired by: https://github.com/zpm-zsh/title
#+begin_src sh
_show_title() {
  # print -Pn "\033]0;${PROMPT_TITLE:-"$USER@$HOST"}\007"
  print -Pn "\033]0;${PROMPT_TITLE}\007"
}

autoload -Uz add-zsh-hook
add-zsh-hook precmd _show_title
_show_title
#+end_src

** Core zsh settings
*** General
Create an associative array.
#+begin_src sh
declare -A ZSH
#+end_src

#+begin_src sh
ZSH[cache]="$HOME/.cache/zsh"
# ZSH[completions]="$ZSH[cache]/completions"
ZSH[completions]="$XDG_DATA_HOME/zsh/site-functions"
ZSH[scripts]="$ZSH[cache]/scripts"
#+end_src

#+begin_src sh
[ -d $ZSH[completions] ] || mkdir -p $ZSH[completions]
[ -d $ZSH[scripts] ] || mkdir -p $ZSH[scripts]
#+end_src

Report time stats of commands running longer than 20 sec.
#+begin_src sh
# REPORTTIME=20
#+end_src

Because someday i will learn advanced pattern matching.
In order to use =#=, =~= and =^= for filename generation grep word
~*~(*.gz|*.bz|*.bz2|*.zip|*.Z)~ -> searches for word not in compressed files don't
forget to quote =^=, =~= and =#=!
#+begin_src sh
setopt extended_glob
#+end_src

#+begin_src sh
setopt auto_cd            # Go to folder path without using cd.
setopt auto_pushd         # Push the old directory onto the stack on `cd`.
setopt pushd_ignore_dups  # Do not store duplicates in the stack.
setopt pushd_silent       # Do not print the directory stack after 'pushd' or 'popd'.
#+end_src

Exchanges the meanings of =+= and =-= when used with a number to specify a directory
in the stack.
#+begin_src sh
setopt pushd_minus
#+end_src

Нельзя вводить пути для команды =cd= (или без неё, если используетя опция ~auto_cd~)
в домашней директории без =~/= в начале.
#+begin_src sh
unsetopt cdable_vars
#+end_src

With this option the =>= redirection, if file exists, truncates it to zero length.
So unset it we NOT allows =>= redirection to truncate existing files. This way =>!=
or =>|= must be used to truncate a file.
#+begin_src sh
unsetopt clobber
#+end_src

Allow comments even in interactive shells.
#+begin_src sh
setopt interactive_comments
#+end_src

#+begin_src sh
setopt nomatch
# unsetopt nomatch         # Don't you yell at me when you can't find a match.
#                          # that's your problem, not mine.
#+end_src

Seriously why does this shit even exist!?
#+begin_src sh
unsetopt beep
#+end_src

Combine zero-length punctuation characters (accents) with the base character.
#+begin_src sh
setopt combining_chars
#+end_src

Allow 'Henry''s Garage' instead of 'Henry'\''s Garage'.
#+begin_src sh
setopt rc_quotes
#+end_src

Whenever a command completion is attempted, make sure the entire command path is
hashed first.
#+begin_src sh
setopt hash_list_all
#+end_src

Jobs
#+begin_src sh
setopt long_list_jobs     # List jobs in the long format by default.
setopt auto_resume        # Attempt to resume existing job before creating a new process.
setopt notify             # Report status of background jobs immediately.
unsetopt bg_nice          # Don't run all background jobs at a lower priority.
unsetopt hup              # Don't kill jobs on shell exit.
unsetopt check_jobs       # Don't report on jobs when shell exit.
#+end_src

Correct the spelling of all arguments in a line.
#+begin_src sh
setopt correct_all
CORRECT_IGNORE_FILE='.*'
#+end_src

Переменная ~$READNULLCMD~ определяет команду, которая будет вызвана, если
перенаправление stdin использовать без ввода команды: ~< file.txt~
#+begin_src sh
READNULLCMD='less'
#+end_src

Если в слове есть ошибка, предложить исправить её.
#+begin_src sh
SPROMPT="Ошибка! ввести %r вместо %R? ([Y]es/[N]o/[E]dit/[A]bort) "
#+end_src

*** Command history managment

#+begin_src sh
# source $ZDOTDIR/settings/history.zsh
#+end_src

#+begin_src sh
HISTFILE=$XDG_CACHE_HOME/zsh/zsh_history  # History filepath
HISTSIZE=11000  # Larger than $SAVEHIST for HIST_EXPIRE_DUPS_FIRST to work.
SAVEHIST=10000
#+end_src

Treat the '!' character specially during expansion.
#+begin_src sh
setopt bang_hist
#+end_src

Write the history file in the ":start:elapsed;command" format.
#+begin_src sh
# setopt extended_history
#+end_src

Write to the history file immediately, not when the shell exits.
#+begin_src sh
setopt inc_append_history
#+end_src

#+begin_src sh
# setopt share_history          # Synchronize history across shells
setopt hist_reduce_blanks     # Remove superfluous blanks before recording entry.
setopt hist_verify            # Don't execute immediately upon history expansion.
#+end_src

Remove the ~history~ (~fc -i~) command form the history list.
#+begin_src sh
setopt hist_no_store
#+end_src

Remove superfluous blanks from each command line being added to the history list.
#+begin_src sh
setopt hist_reduce_blanks
#+end_src

#+begin_src sh
setopt prompt_subst           # Allow expansion in prompts
setopt hist_find_no_dups      # Do not display a line previously found.
setopt hist_ignore_dups       # Don't record an entry that was just recorded again.
setopt hist_ignore_space      # Don't record an entry starting with a space.
setopt hist_expire_dups_first # Delete duplicates first when HISTFILE size exceeds HISTSIZE.
# setopt hist_ignore_all_dups   # Delete old recorded entry if new entry is a duplicate.
# setopt hist_save_no_dups      # Don't write duplicate entries in the history file.
#+end_src

Not store failed commands into history.
#+begin_src sh
zshaddhistory() {
  whence ${${(z)1}[1]} >/dev/null || return 2
}
#+end_src

Patterns that would not be stored in history.
#+begin_src sh
export HISTORY_IGNORE="(cd|ranger|r|exit|:q|kill|vifm*)"
#+end_src

** Completion
*** Completion settings
- [[https://thevaluable.dev/zsh-completion-guide-examples/][A Guide to the Zsh Completion with Examples]]
**** Shell completion settings
For more information open =man zshoptions= and search for “Completion”.

При множестве вариатнов подстановки по нажатию =<Tab>= откроет меню и подставит
первый вариант. При повторном нажатии подставит следующий вариант. В меню можно
пользоваться стрелками.
#+begin_src sh
setopt menu_complete
#+end_src

Show completion menu on a successive tab press (two use of the Tab key). This
option is overridden by ~MENU_COMPLETE~.
#+begin_src sh
# setopt auto_menu
#+end_src

Select the first match given by the completion menu. Override ~AUTO_MENU~.
#+begin_src sh
# setopt auto_complete
#+end_src

Matches are sorted in rows instead of columns.
#+begin_src sh
# setopt list_rows_first
#+end_src

Дополнять aliaces как отдельные команды.
#+begin_src sh
setopt complete_aliases
#+end_src

When listing files that are possible completions, show the type of each file
with a trailing identifying mark.
#+begin_src sh
setopt list_types
#+end_src

Disable start/stop characters in shell editor.
#+begin_src sh
unsetopt flow_control
#+end_src

Makes globbing (filename generation) case-sensitive.
#+begin_src sh
# unsetopt case_glob
#+end_src

#+begin_src sh
setopt always_to_end    # Move cursor to the end of a completed word.
setopt list_packed      # The completion menu takes less space.
setopt auto_list        # Automatically list choices on ambiguous completion.
setopt auto_param_slash # If completed parameter is a directory, add a trailing slash.
#+end_src

By default, the cursor goes at the end of the word when completion start.
Setting this will not move the cursor and the completion will happen on both end
of the word completed.
#+begin_src sh
setopt complete_in_word
#+end_src

Trigger the completion after a glob =*= instead of expanding it.
#+begin_src sh
setopt glob_complete
#+end_src

This option EXTREMELY SLOWS DOWN COMPLETION.
Perform path search even on command names with slashes.
#+begin_src sh
unsetopt path_dirs
#+end_src

Dotfiles are matched without explicitly specifying the dot.
#+begin_src sh
unsetopt glob_dots
#+end_src

**** zstyle

The general way to use zstyle to configure a Zsh module:
#+begin_src
zstyle <pattern> <style> <values>
#+end_src

zstyle pattern for the completion:
#+begin_src
:completion:<function>:<completer>:<command>:<argument>:<tag>
#+end_src

- completion ::
  String acting as a namespace, to avoid pattern collisions with other scripts
  also using zstyle.

- <function> ::
  Apply the style to the completion of an external function or widget.

- <completer> ::
  Apply the style to a specific completer. We need to drop the underscore from
  the completer’s name here.

- <command> ::
  Apply the style to a specific command, like cd, rm, or sed for example.

- <argument> ::
  Apply the style to the n-th option or the n-th argument. It’s not available
  for many styles.

- <tag> ::
  Apply the style to a specific tag. You can think of a tag as a type of match.
  For example “files”, “domains”, “users”, or “options” are tags.

#+begin_src
$ man zshcompsys
#+end_src
List of styles -- search for “Standard Styles”.
List of tags -- search for “Standard Tags”.

#+begin_src sh
zstyle ':completion:*' verbose true
#+end_src

Define completers
#+begin_src sh
zstyle ':completion:*' completer _extensions _complete _approximate
#+end_src

Some functions, like =_apt= and =_dpkg=, are very slow. It is possible to use a
cache in order to proxy the list of results (like the list of available debian
packages).
#+begin_src sh
zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path $HOME/.cache/zsh/.zcompcache
#+end_src

This style is used by _expand_alias function. Set to complete the aliases.
#+begin_src sh
zstyle ':completion:*' complete true
#+end_src

Do not insert Tab when the are no characters to the left of the cursor.
#+begin_src sh
zstyle ':completion:*' insert-tab false
#+end_src

Autocomplete options for cd instead of directory stack
#+begin_src sh
zstyle ':completion:*' complete-options true
#+end_src

In which order sort files on completion.
Possible values: size, link, time, modification, access.
#+begin_src sh
zstyle ':completion:*' file-sort alphabetically
#+end_src

provide .. as a completion
#+begin_src sh
# zstyle ':completion:*' special-dirs ..
#+end_src

cd will never select the parent directory (e.g.: cd ../<TAB>):
#+begin_src sh
zstyle ':completion:*:cd:*' ignore-parents parent pwd
#+end_src

Don't complete backup files as executables.
#+begin_src sh
zstyle ':completion:*:complete:-command-::commands' ignored-patterns '(aptitude-*|*\~)'
#+end_src

Enable filename colorizing according to ls colors for zsh completion.
#+begin_src sh
zstyle ':completion:*:*:*:*:default' list-colors ${(s.:.)LS_COLORS}
#+end_src

Directories
#+begin_src sh
zstyle ':completion:*:*:cd:*' tag-order local-directories directory-stack path-directories
zstyle ':completion:*:*:cd:*:directory-stack' menu yes select
zstyle ':completion:*:-tilde-:*' group-order 'named-directories' 'path-directories' 'users' 'expand'
#+end_src

History. Ignore duplicate entries.
#+begin_src sh
zstyle ':completion:*:history-words' remove-all-dups yes
zstyle ':completion:*:history-words' stop yes
zstyle ':completion:*:history-words' list false
zstyle ':completion:*:history-words' menu yes
#+end_src

Environment Variables
#+begin_src sh
zstyle ':completion::*:(-command-|export):*' fake-parameters ${${${_comps[(I)-value-*]#*,}%%,*}:#-*-}
#+end_src

If you end up using a directory as argument, this will remove the trailing slash
(usefull in ln).
#+begin_src sh
zstyle ':completion:*' squeeze-slashes true
#+end_src

Уравниваем в правах верхний и нижний регистр
#+begin_src sh
zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=* l:|=*'
#+end_src

Completing process IDs with menu selection:
#+begin_src sh
zstyle ':completion:*:kill:*' force-list always
#+end_src

Disable sort when completing =git checkout=.
#+begin_src sh
zstyle ':completion:*:git-checkout:*' sort false
#+end_src

#+begin_src sh
zstyle ':completion:*:functions' ignored-patterns '(_*|pre(cmd|exec))'
#+end_src

On processes completion complete all user processes.
#+begin_src sh
zstyle ':completion:*:processes' command 'ps -au$USER'
#+end_src

Array completion element sorting. Offer indexes before parameters in subscripts.
#+begin_src sh
zstyle ':completion:*:*:-subscript-:*' tag-order indexes parameters
#+end_src

Don't complete uninteresting users
#+begin_src sh
zstyle ':completion:*:*:*:users' ignored-patterns \
        adm amanda apache at avahi avahi-autoipd beaglidx bin cacti \
        canna clamav daemon dbus distcache dnsmasq dovecot fax ftp \
        games gdm gkrellmd gopher hacluster haldaemon halt hsqldb ident \
        junkbust kdm ldap lp mail mailman mailnull man messagebus \
        mldonkey mysql nagios named netdump news nfsnobody nobody nscd \
        ntp nut nx obsrun openvpn operator pcap polkitd postfix \
        postgres privoxy pulse pvm quagga radvd rpc rpcuser rpm rtkit \
        scard shutdown squid sshd statd svn sync tftp usbmux uucp vcsa \
        wwwrun xfs '_*'
#+end_src
... unless we really want to.
#+begin_src sh
zstyle '*' single-ignored show
#+end_src

Ignore multiple entries.
#+begin_src sh
zstyle ':completion:*:(rm|kill|diff):*' ignore-line other
zstyle ':completion:*:rm:*' file-patterns '*:all-files'
#+end_src

Man. Complete manual by their section.
#+begin_src sh
zstyle ':completion:*:manuals'       separate-sections true
zstyle ':completion:*:manuals.(^1*)' insert-sections true
#+end_src

Media Players
#+begin_src sh
zstyle ':completion:*:*:mpg123:*' file-patterns '*.(mp3|MP3):mp3\ files *(-/):directories'
zstyle ':completion:*:*:mpg321:*' file-patterns '*.(mp3|MP3):mp3\ files *(-/):directories'
zstyle ':completion:*:*:ogg123:*' file-patterns '*.(ogg|OGG|flac):ogg\ files *(-/):directories'
zstyle ':completion:*:*:mocp:*' file-patterns '*.(wav|WAV|mp3|MP3|ogg|OGG|flac):ogg\ files *(-/):directories'
#+end_src

Insert all expansions for expand completer
#+begin_src sh
zstyle ':completion:*:expand:*' tag-order all-expansions
zstyle ':completion:*:history-words' list false
#+end_src

Define files to ignore for zcompile
#+begin_src sh
zstyle ':completion:*:*:zcompile:*' ignored-patterns '(*~|*.zwc)'
zstyle ':completion:correct:' prompt 'correct to: %e'
#+end_src

Ignore completion functions for commands you don't have:
#+begin_src sh
zstyle ':completion::(^approximate*):*:functions' ignored-patterns '_*'
#+end_src

Provide more processes in completion of programs like killall:
#+begin_src sh
zstyle ':completion:*:processes-names' command 'ps c -u ${USER} -o command | uniq'
#+end_src

Search path for sudo completion.
#+begin_src sh
zstyle ':completion:*:sudo:*' command-path /usr/local/sbin \
                                           /usr/local/bin  \
                                           /usr/sbin       \
                                           /usr/bin        \
                                           /sbin           \
                                           /bin            \
                                           /usr/X11R6/bin
#+end_src

***** Group matches and describe.

Categorize completion suggestions with headings.
Required for completion to be in good groups (named after the tags).
#+begin_src sh
zstyle ':completion:*' group-name ''
#+end_src

#+begin_src sh
zstyle ':completion:*:*:-command-:*:*' group-order aliases builtins functions commands
#+end_src

Style the group names
:                underline              end bold
:               ~v                     ~v
: $'%F{yellow}%B%U%{\e[3m%}%d%{\e[23m%}%b%u%f'
:             ~^  ^~~~~~~~~  ^~~~~~~~~~  ~^
:           bold  italic     end italic   end underline
:
: zstyle ':completion:*' format $' %F{yellow}%B%{\e[3m%}%d%{\e[23m%}%b%f'

Describe options in full.
#+begin_src sh
zstyle ':completion:*:options' description 'yes'
zstyle ':completion:*:options' auto-description '%d'
#+end_src

#+begin_src sh
zstyle ':completion:*:*:*:*:corrections'  format 'F{green}!- %d (errors: %e) -!%f'
zstyle ':completion:*:*:*:*:descriptions' format '%F{blue}%B-- %D %d --%b%f'
zstyle ':completion:*:*:*:*:messages'     format ' %F{yellow} -- %d --%f'
zstyle ':completion:*:*:*:*:warnings'     format ' %F{magenta}-- no matches found --%f'
zstyle ':completion:*:default' list-prompt '%S%M matches%s'
#+end_src

***** Menu
Use the menu to select zsh completion suggestions.
#+begin_src sh
zstyle ':completion:*' menu select=1
# zstyle ':completion:*' menu select=1 _complete _ignored _approximate
#+end_src

****** Navigation in completion menu

Use the vi navigation keys (hjkl) besides cursor keys in menu completion.
#+begin_src sh
zmodload zsh/complist  # Should be called before compinit.
#+end_src

#+begin_src sh
bindkey -M menuselect 'h' vi-backward-char         # left
bindkey -M menuselect 'k' vi-up-line-or-history    # up
bindkey -M menuselect 'l' vi-forward-char          # right
bindkey -M menuselect 'j' vi-down-line-or-history  # down
#+end_src

#+begin_src sh
bindkey -M menuselect '^f' vi-forward-word   # moves one screenful down
bindkey -M menuselect '^b' vi-backward-word  # moves one screenful up
#+end_src

#+begin_src sh
bindkey -M menuselect 'gg' beginning-of-history  # moves to the first line
bindkey -M menuselect 'G'  end-of-history        # moves to the last line
#+end_src

Undo the completion and restore the previous content of the command line.
#+begin_src sh
bindkey -M menuselect '^[' send-break  # escape
#+end_src

Shift-Tab to go back in completion menu
#+begin_src sh
bindkey -M menuselect '^[[Z' reverse-menu-complete
#+end_src

**** Corrections

Run rehash on completion so new installed program are found automatically:
#+begin_src sh
_force_rehash() {
  (( CURRENT == 1 )) && rehash
  return 1  # Because we didn't really complete anything
}
#+end_src

Some people don't like the automatic correction - so add
~export NO_CORRECTIONS=1~ in =.zprofile= to deactivate it.

#+begin_src sh
if [[ -n "$NO_CORRECTIONS" ]]; then
  setopt nocorrect # Do not try to correct the spelling if possible.
  zstyle ':completion:*' completer _oldlist _expand _force_rehash _complete _files
else
  setopt correct   # Correct the spelling of commands.

  # Fuzzy matching of completions for when you mistype them:
  zstyle -e ':completion:*' completer '
    if [[ $_last_try != "$HISTNO$BUFFER$CURSOR" ]]; then
      _last_try="$HISTNO$BUFFER$CURSOR"
      reply=(_complete _match _ignored _prefix _files)
    else
      if [[ $words[1] == (rm|mv) ]]; then
        reply=(_complete _files)
      else
        reply=(_oldlist _expand _force_rehash _complete _ignored _correct _approximate _files)
      fi
    fi'
fi
#+end_src

~original~ style is used by the ~_approximate~ and ~_correct~ completers to
decide if the original string should be added as a  possible completion.

#+begin_src sh
zstyle ':completion:*' original true
# zstyle ':completion:*:match:*' original only
#+end_src

***** max-errors
The style ~max-errors~ is used by the ~_approximate~ and ~_correct~ completer
functions to determine the maximum number of errors to allow.

  #+begin_src sh :tangle no
  zstyle ':completion:*:approximate:*' max-errors 2 numeric
  #+end_src

Increase the number of errors based on the length of the typed word. But make
sure to cap (at 7) the max-errors to avoid hanging.

#+begin_src sh
zstyle -e ':completion:*:approximate:*' \
  max-errors 'reply=($((($#PREFIX+$#SUFFIX)/3>7?7:($#PREFIX+$#SUFFIX)/3))numeric)'
#+end_src

*** Completion sources

#+begin_src sh
# source $ZDOTDIR/settings/completion.zsh
#+end_src

#+begin_src sh
fpath+=(
  $ZSH[completions]
)
#+end_src

#+begin_src sh
znap install zsh-users/zsh-completions
#+end_src

#+begin_src sh
# github_completion exa 'https://github.com/ogham/exa/blob/master/completions/zsh/_exa'
# github_completion rg 'https://github.com/BurntSushi/ripgrep/blob/master/complete/_rg'
# github_completion vifm 'https://github.com/vifm/vifm/blob/master/data/shell-completion/zsh/_vifm'
#+end_src

#+begin_src sh
znap fpath _gh 'gh completion -s zsh'
#+end_src

conda completion
#+begin_src sh
znap install esc/conda-zsh-completion

# zstyle ":conda_zsh_completion:*" use-groups true

# # Display unnamed environments and prefixes of environments.
# zstyle ":conda_zsh_completion:*" show-unnamed true

# # display environments autocompletion sorted in creation order
# zstyle ":conda_zsh_completion:*" sort-envs-by-time true
#+end_src

#+begin_src sh
znap fpath _pip "pip completion --zsh"
#+end_src

#+begin_src sh
if (( $+commands[pipx] )) && (( $+commands[register-python-argcomplete] )); then
  znap eval pipx-completion "register-python-argcomplete pipx"
fi
#+end_src

#+begin_src sh
compdef _gnu_generic update-alternatives
#+end_src

# zinit snippet OMZ::plugins/fd/_fd

zoxide completions
#+begin_src sh
function _zoxide_zsh_tab_completion {
    (( $+compstate )) && compstate[insert]=menu
    local keyword="${words:2}"
    local completions=(${(@f)"$(zoxide query -l "$keyword")"})

    if [[ ${#completions[@]} == 0 ]]; then
        _files -/
    else
        compadd -U -V z "${(@)completions}"
    fi
}

if (( $+functions[compdef] )); then
    compdef _zoxide_zsh_tab_completion z 2>/dev/null
fi
#+end_src

** Functions
*** Expand aliaces
[[https://blog.sebastian-daschner.com/entries/zsh-aliases][Source]]

Define three types of aliaces:
- alias  :: will be expanded into full command with wightspace after;
- balias :: will be expanded without wightspace after;
- ialias :: won't be expanded.

**** Blank aliases
#+begin_src sh
typeset -a baliases
baliases=()

balias() {
    alias $@
    args="$@"
    args=${args%%\=*}
    baliases+=(${args##* })
}
#+end_src

**** Ignored aliases
#+begin_src sh
typeset -a ialiases
ialiases=()

ialias() {
  alias $@
  args="$@"
  args=${args%%\=*}
  ialiases+=(${args##* })
}
#+end_src

**** Main function
#+begin_src sh
expand-alias-space() {
  [[ $LBUFFER =~ "\<(${(j:|:)baliases})\$" ]]; insertBlank=$?
  if [[ ! $LBUFFER =~ "\<(${(j:|:)ialiases})\$" ]]; then
    zle _expand_alias
  fi
  zle self-insert
  if [[ "$insertBlank" = "0" ]]; then
    zle backward-delete-char
  fi
}
zle -N expand-alias-space
#+end_src

**** Expand aliaces on space
#+begin_src sh
bindkey " " expand-alias-space
bindkey -M isearch " " magic-space
#+end_src

*** Bash =help= function analog
#+begin_src sh
# unalias run-help
autoload run-help

# HELPDIR=/usr/share/zsh/"${ZSH_VERSION}"/help
HELPDIR=/usr/share/zsh/help  # in Pop_OS
#+end_src

*** File managers invocation
#+begin_src sh
run_vifm()
{
  zle .reset-prompt
  BUFFER=" vifmcd"
  zle accept-line
}
zle -N run_vifm
#+end_src

#+begin_src sh
run_ranger() {
  zle .reset-prompt
  # BUFFER=" source ranger && clear -x"
  BUFFER=" source ranger"
  zle accept-line
}
zle -N run_ranger
#+end_src

** Plugins
*** fzf-tab
*WARNING*: *fzf-tab* needs to be loaded after =compinit=, but before plugins which
will wrap widgets, such as *zsh-autosuggestions* or *fast-syntax-highlighting*!!

#+begin_src sh
znap source Aloxaf/fzf-tab
#+end_src

Use tmux popup windows.
#+begin_src sh
zstyle ':fzf-tab:*' fzf-command ftb-tmux-popup
#+end_src

Set descriptions format to enable group support.
#+begin_src sh
zstyle ':completion:*:descriptions' format '-- %d --'
#+end_src

Preview directory's content with exa when completing cd.
#+begin_src sh
# zstyle ':fzf-tab:complete:cd:*' fzf-preview 'exa -1 --color=always $realpath'
# zstyle ':fzf-tab:complete:cd:*' popup-pad 80 0
#+end_src

Colors
#+begin_src sh
# A prefix to indicate the color.
zstyle ':fzf-tab:*' prefix ''
# zstyle ':fzf-tab:*' prefix '·'

local lc=$'\e[' rc=m    # Standard ANSI terminal escape values.
local rgb="${lc}38;2;"  # RGB color support
local reset="${lc}0;${rc}"
FZF_TAB_GROUP_COLORS=(
  "${rgb}171;178;191${rc}"  # #abb2bf
  "${rgb}157;226;199${rc}"  # #9de2c7
  "${rgb}226;157;226${rc}"  # #e29de2
  "${rgb}205;212;96${rc}"   # #CDD460
  "${rgb}115;184;241${rc}"  # #73b8f1
  "${rgb}241;167;173${rc}"  # #f1a7ad
  "${rgb}229;192;123${rc}"  # #e5c07b
  "${rgb}209;179;255${rc}"  # #d1b3ff
  "${rgb}164;210;121${rc}"  # #a4d279
  "${rgb}162;176;246${rc}"  # #a2b0f6
)
zstyle ':fzf-tab:*' group-colors $FZF_TAB_GROUP_COLORS
#+end_src

#+begin_src sh
completion-switch() {
  if $FZF_TAB_ENABLED; then
    disable-fzf-tab
    zstyle ':completion:*:*:*:*:descriptions' format '%F{blue}%B-- %D%d --%b%f'
    FZF_TAB_ENABLED=false
  else
    enable-fzf-tab
    zstyle ':completion:*:*:*:*:descriptions' format '-- %d --'
    FZF_TAB_ENABLED=true
  fi
}
zle -N completion-switch
#+end_src

#+begin_src sh
FZF_TAB_ENABLED=false
completion-switch
#+end_src

*** zsh-autosuggestions
#+begin_src sh
znap source zsh-users/zsh-autosuggestions
#+end_src

#+begin_src sh
export ZSH_AUTOSUGGEST_STRATEGY=(match_prev_cmd history completion)
export ZSH_AUTOSUGGEST_USE_ASYNC=1  # suggestions will be fetched asynchronously
#+end_src

Speed up pasting w/ autosuggest
https://github.com/zsh-users/zsh-autosuggestions/issues/238
#+begin_src sh
pasteinit() {
  OLD_SELF_INSERT=${${(s.:.)widgets[self-insert]}[2,3]}
  zle -N self-insert url-quote-magic
}

pastefinish() {
  zle -N self-insert $OLD_SELF_INSERT
}
#+end_src

#+begin_src sh
zstyle :bracketed-paste-magic paste-init pasteinit
zstyle :bracketed-paste-magic paste-finish pastefinish
#+end_src

Clear suggestions on paste
https://github.com/zsh-users/zsh-autosuggestions/issues/351
#+begin_src sh
ZSH_AUTOSUGGEST_CLEAR_WIDGETS+=(bracketed-paste)
#+end_src

*** zsh-vi-mode

Do the initialization when the script is sourced (i.e. Initialize instantly).
#+begin_src sh
# ZVM_INIT_MODE=sourcing
#+end_src

*WARNING:* temporary switch to a particular commit (see this [[https://github.com/jeffreytse/zsh-vi-mode/issues/122][issue]])
#+begin_src sh
# if [[ ! -d $ZNAP[PLUGINS]/jeffreytse/zsh-vi-mode ]]; then
#   git clone "https://github.com/jeffreytse/zsh-vi-mode.git" $ZNAP[PLUGINS]/jeffreytse/zsh-vi-mode
#   git -C $ZNAP[PLUGINS]/zsh-vi-mode checkout c1480b4
# fi
#+end_src

#+begin_src sh
znap source jeffreytse/zsh-vi-mode
#+end_src

#+begin_src sh
ZVM_VI_SURROUND_BINDKEY=classic
ZVM_READKEY_ENGINE=$ZVM_READKEY_ENGINE_DEFAULT
#+end_src

Cursor shape
#+begin_src sh
ZVM_NORMAL_MODE_CURSOR=$ZVM_CURSOR_BLOCK
ZVM_INSERT_MODE_CURSOR=$ZVM_CURSOR_UNDERLINE
#+end_src

- =C-r= :: fussy search in history with mcfly.
#+begin_src sh
# zvm_after_init_commands+=(
#   #
#   "zvm_bindkey viins '^R' mcfly-history-widget"
# )
#+end_src

 #+begin_src sh
zvm_after_init_commands+=(
  zvm_after_keybindings
)
 #+end_src

*** fzf
╭────────────────────────────────────────────────────────────────────────╮
│ fzf keybindings for Zsh                                                │
│ ───────────────────────                                                │
│ CTRL-R - Paste the selected command from history into the command line │
│ CTRL-T - Paste the selected file path(s) into the command line         │
│ ALT-C  - cd into the selected directory                                │
│                                                                        │
│ fzf completion for Zsh                                                 │
│ ──────────────────────                                                 │
│ Fuzzy completion for files and directories can be triggered if the     │
│ word before the cursor ends with the trigger sequence which is by      │
│ default **.                                                            │
│                                                                        │
│ fzf-marks                                                              │
│ ─────────                                                              │
│ mark <name> - register a new mark to the current directory             │
│ CTRL-F - fzf-marks                                                     │
╰────────────────────────────────────────────────────────────────────────╯

fzf keybindings
#+begin_src sh
# znap source junegunn/fzf shell/key-bindings.zsh
gitfile $ZSH[scripts]/fzf-key-bindings.zsh 'https://github.com/junegunn/fzf/blob/master/shell/key-bindings.zsh'
source $ZSH[scripts]/fzf-key-bindings.zsh
#+end_src

#+begin_src sh
# gitfile $HOME/.local/bin/fzf-tmux 'https://github.com/junegunn/fzf/blob/master/bin/fzf-tmux'
#+end_src

Use fzf for completion.
#+begin_src sh
# gitfile $ZSH[scripts]/fzf-completion.zsh 'https://github.com/junegunn/fzf/blob/master/shell/completion.zsh'
# source $ZSH[scripts]/fzf-completion.zsh
#+end_src

fzf man page
#+begin_src sh
gitfile $HOME/.local/share/man/man1/fzf.1 'https://github.com/junegunn/fzf/blob/master/man/man1/fzf.1'
#+end_src

fzf-marks
#+begin_src sh
# gitfile $ZSH[scripts]/fzf-marks.zsh 'https://github.com/urbainvaes/fzf-marks/blob/master/fzf-marks.plugin.zsh'
# source $ZSH[scripts]/fzf-marks.zsh
#
# export FZF_MARKS_FILE="${HOME}/.cache/zsh/fzf-marks"
#
# export FZF_MARKS_JUMP='^f'  # Ctrl-f
# bindkey ${FZF_MARKS_JUMP:-'^g'} fzm
#+end_src

fzf.vim  Needed to enable fzf in vim/neovim.
#+begin_src sh
# zinit ice wait"2" lucid id-as"auto" as"null"
# zinit snippet https://github.com/junegunn/fzf/blob/master/plugin/fzf.vim
#+end_src

#+begin_src sh
# export FZF_TMUX_OPTS="-p"
#+end_src

#+begin_src sh
export FZF_DEFAULT_OPTS='--height 70% --layout=reverse --border'
# export FZF_DEFAULT_OPTS='--height 75% --layout=reverse --border --preview="head -30 {}"'
# export FZF_DEFAULT_OPTS="--reverse --preview 'echo {}' --preview-window down:3:hidden:wrap --bind '?:toggle-preview'"
#+end_src

Using ripgrep with fzf. (I've tried fd, but ripgrep is faster.)
Keys:
- =--files=      :: List files that would be searched but do not search.
- =--no-ignore=  :: Do not respect .gitignore, etc...
- =--hidden=     :: Search hidden files and folders.
- =--follow=     :: Follow symlinks.
- =-g= or =--glob= :: Additional conditions for search (in this case ignore
                  everything in the .git/ folder).
#+begin_src sh
# export FZF_DEFAULT_COMMAND='rg --files --no-ignore --hidden --follow -g "!{.git,node_modules}/*" 2> /dev/null'
export FZF_DEFAULT_COMMAND='rg --files --no-ignore --hidden --follow -g "!{.git,node_modules}" 2> /dev/null'
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
#+end_src

**** Using bfs utility for directory searching.
[[https://github.com/tavianator/bfs][tavianator/bfs]]
#+begin_src sh
if (( $+commands[bfs] )); then
  # # don't show hidden folders
  # export FZF_ALT_C_COMMAND="bfs -type d -nohidden -L -print 2> /dev/null"

  # show hidden folders
  export FZF_ALT_C_COMMAND="bfs -type d -L -print 2> /dev/null"
else
  print $(color Yellow 'Warning:') $(color White 'fzf') use $(color White 'bfs') utility but it is $(color Red 'not installed\!')
  print $(color White "https://github.com/tavianator/bfs")
fi
#+end_src

**** COMMENT Make fzf history search unique
*Now this functionality is built-in.*
#+begin_src sh
fzf-history-widget() {
  local selected num
  setopt localoptions noglobsubst noposixbuiltins pipefail no_aliases 2> /dev/null
  selected=( $(fc -rl 1 | perl -ne 'print if !$seen{(/^\s*[0-9]+\s+(.*)/, $1)}++' |
    sort -k2 -k1rn | uniq -f 1 | sort -r -n |
    FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} $FZF_DEFAULT_OPTS -n2..,.. --tiebreak=index --bind=ctrl-r:toggle-sort $FZF_CTRL_R_OPTS --query=${(qqq)LBUFFER} +m" $(__fzfcmd)) )
  local ret=$?
  if [ -n "$selected" ]
  then
    num=$selected[1]
    if [ -n "$num" ]
    then
      zle vi-fetch-history -n $num
    fi
  fi
  zle reset-prompt
  return $ret
}
#+end_src

**** Custom CTRL-T command

Make =CTRL-T= command return full path to the file, not relevant to =$PWD=.
Also if this path is inside the =$HOME= directory the =$HOME= prefix exchange
to tilda =~= symbol.
#+begin_src sh
fzf-file-widget() {

  # If $PWD is not root ('/') add '/' char to make path valid.
  if [ ${PWD} = '/' ]
  then
    local fzf_full_path="/$(__fsel)"
  else
    local fzf_full_path="${PWD}/$(__fsel)"
  fi

  # Exchange the substring at the beginning of the $fzf_full_path
  # variable equal to ${HOME} with '~' symbol.
  fzf_full_path="${fzf_full_path/#${HOME}/~}"

  LBUFFER="${LBUFFER}${fzf_full_path}"

  local ret=$?
  zle reset-prompt
  return $ret
}
#+end_src

*** atuin
Place it after ~fzf~, because another way ~fzf~ will overwrite ~atuin~ keybindings.
#+begin_src sh
. "$HOME/.atuin/bin/env"
eval "$(atuin init zsh)"
#+end_src

*** zoxide
#+begin_src sh
if (( $+commands[zoxide] )); then
  _ZO_ECHO=1
  znap eval zoxide 'zoxide init zsh'
fi
#+end_src

*** vifm
Image previews using Überzug for Vifm
#+begin_src sh
# znap install cirala/vifmimg
znap install anuvyklack/vifmimg
#+end_src

#+begin_src sh
export VIFM_PANE_STRATEGY=left
znap install anuvyklack/vifmpane
#+end_src

*** conda
#+begin_src sh
local -A CONDA
CONDA[home]="/opt/miniconda3"
CONDA[version]=$($CONDA[home]/bin/conda --version)

znap eval conda "${CONDA[home]}/bin/conda shell.zsh hook  # $CONDA[version]"
#+end_src

*** COMMENT zsh-interactive-cd
#+begin_src sh
znap source changyuheng/zsh-interactive-cd
#+end_src

*** COMMENT mcfly
#+begin_src sh
if (( $+commands[mcfly] )); then
  export HISTFILE=$ZSH[cache]/zsh_history
  export MCFLY_KEY_SCHEME=vim
  export MCFLY_FUZZY=true
  export MCFLY_RESULTS=30
  znap eval mcfly 'mcfly init zsh'
fi
#+end_src

*** COMMENT nnn
#+begin_src sh :noweb yes
if (( $+commands[nnn] )); then
  <<nnn-config>>
fi
#+end_src

**** Config for *nnn* file manager
Completion and manual
#+begin_src sh
github_completion nnn 'https://github.com/jarun/nnn/blob/master/misc/auto-completion/zsh/_nnn'
#+end_src

manual
#+begin_src sh
gitfile $HOME/.local/share/man/man1/nnn.1 'https://github.com/jarun/nnn/blob/master/nnn.1'
#+end_src

plugins
#+begin_src sh
gitfile ${XDG_CONFIG_HOME:-$HOME/.config}/nnn/plugins/autojump 'https://github.com/jarun/nnn/blob/master/plugins/autojump'
#+end_src

Cd into last dir on quit nnn.
#+begin_src sh
nnn_quitcd() {
  zle .reset-prompt
  BUFFER=" n && clear -x"
  zle accept-line
}
zle -N nnn_quitcd
#+end_src

nnn bookmarks
#+begin_src sh
export NNN_BMS='d:~/Documents;D:~/Downloads/'
#+end_src

Options to nnn binary:
- -e :: text in $VISUAL/$EDITOR/vi
- -E :: use EDITOR for undetached edits
- -r :: use advcpmv patched cp, mv
- -x :: notis, sel to system clipboard
- -C :: color by context
#+begin_src sh
# export NNN_OPTS="eErx"
export NNN_OPTS="eExC"
#+end_src

Contexts (tabs) colors
#+begin_src sh
export NNN_COLORS='4321'
#+end_src

File-specific colors
#+begin_src sh
BLK='c1'      # Block device               c1  DarkSeaGreen1
CHR='e2'      # Char device                e2  Yellow1
DIR='27'      # Directory                  27  DeepSkyBlue1
EXE='2e'      # Executable                 2e  Green1
REG='00'      # Regular                    00  Normal
HARDLINK='60' # Hard link                  60  Plum4
SYMLINK='33'  # Symbolic link              33  Cyan1
MISSING='f7'  # Missing OR file details    f7  Grey62
ORPHAN='c6'   # Orphaned symbolic link     c6  DeepPink1
FIFO='d6'     # FIFO                       d6  Orange1
SOCK='ab'     # Socket                     ab  MediumOrchid1
OTHER='c4'    # Unknown OR 0B regular/exe  c4  Red1

# export NNN_FCOLORS='c1e20402006033f7c6d6ab01'
export NNN_FCOLORS="$BLK$CHR$DIR$EXE$REG$HARDLINK$SYMLINK$MISSING$ORPHAN$FIFO$SOCK$OTHER"
#+end_src


always cd on quit
#+begin_src sh
export NNN_TMPFILE='/tmp/.lastd'
#+end_src

#+begin_src sh
export NNN_ARCHIVE="\\.(7z|a|ace|alz|arc|arj|bz|bz2|cab|cpio|deb|gz|jar|lha|lz|lzh|lzma|lzo|rar|rpm|rz|t7z|tar|tbz|tbz2|tgz|tlz|txz|tZ|tzo|war|xpi|xz|Z|zip)$"
#+end_src

FIFO to write hovered file path to:
#+begin_src sh
export NNN_FIFO='/tmp/nnn.fifo'
#+end_src

plugins
#+begin_src sh
# export NNN_PLUG='f:finder;o:fzopen;p:mocplay;d:diffs;t:nmount;v:imgview'
# export NNN_PLUG='z:autojump;v:preview-tabbed'
export NNN_PLUG='z:autojump;w:preview-tui'
#+end_src

*** COMMENT broot
#+begin_src sh
if [[ -s "~/.config/broot/launcher/bash/br" ]]; then
    source ~/.config/broot/launcher/bash/br
fi
#+end_src

*** COMMENT nb
#+begin_src sh
znap install xwmx/nb
github_completion nb 'https://github.com/xwmx/nb/blob/master/etc/nb-completion.zsh'
#+end_src

*** COMMENT universalarchive
#+begin_src sh
znap source ohmyzsh/ohmyzsh plugins/universalarchive
github_completion universalarchive \
  'https://github.com/ohmyzsh/ohmyzsh/blob/master/plugins/universalarchive/_universalarchive'
#+end_src

*** WARNING This two plugins should be last in this order!
#+begin_src sh
ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets)
znap source zsh-users/zsh-syntax-highlighting
#+end_src

#+begin_src sh
znap source zsh-users/zsh-history-substring-search
#+end_src

** Key bindings

In Vi mode, there are following keymaps:
| ~viins~  | insert mode      |
| ~viins~  | insert mode      |
| ~vicmd~  | command mode     |
| ~viopp~  | operator pending |
| ~visual~ | selection active |

#+begin_src sh
zvm_after_keybindings() {
  # <C-r> - fussy search in history.
  zvm_bindkey viins '^r' fzf-history-widget
  # zvm_bindkey viins '^r' mcfly-history-widget

  # Switch group in fzf-tab with `,` and `.` ('<' and '>' keys).
  zstyle ':fzf-tab:*' switch-group ',' '.'

  zvm_bindkey viins "^k" history-substring-search-up
  zvm_bindkey viins "^j" history-substring-search-down
}
#+end_src

Backtick (=~= key) --- accept zsh-autosuggestions.
#+begin_src sh
bindkey \` autosuggest-accept
#+end_src

=Shift+Tab= --- switch between zsh compsys and fzf-tab completions.
#+begin_src sh
# bindkey '^[[Z' toggle-fzf-tab
bindkey '^[[Z' completion-switch
#+end_src

#+begin_src sh
# bindkey "^K" history-substring-search-up
# bindkey "^J" history-substring-search-down
#+end_src

=Alt+h= --- show man page of current command.
#+begin_src sh
bindkey '\eh' run-help
#+end_src

Gets the n-th argument from the last command by pressing =Alt+1=, =Alt+2=, ... =Alt+5=.
#+begin_src sh
bindkey -s '\e1' "!:0-0 \t"
bindkey -s '\e2' "!:1-1 \t"
bindkey -s '\e3' "!:2-2 \t"
bindkey -s '\e4' "!:3-3 \t"
bindkey -s '\e5' "!:4-4 \t"
#+end_src

=C-o= - launch file manager and cd to the last directory after closing it.
#+begin_src sh
# bindkey '^o' run_ranger
bindkey '^o' run_vifm
#+end_src

** Aliaces

Remove duplicate lines from the history file preserving their order.
#+begin_src sh
alias history_clear_dups="awk '!visited[$0]++' $ZSH[cache]/zsh_history | sponge $ZSH[cache]/zsh_history"
#+end_src

Lists the ten most used commands.
#+begin_src sh
ialias history_stat="history 0 | awk '{print \$2}' | sort | uniq -c | sort -n -r | head"
#+end_src

#+begin_src sh
ialias -g L='| less'
#+end_src

#+begin_src sh
ialias cls='clear'      # clear the screen
ialias help='run-help'  # Bash 'help' function analog.
ialias ping='ping -c 1' # Пингуем один раз вместо бесконечности.
ialias tree='tree -I .git -I .github'
#+end_src

Вывод свободного и использованного дискового пространства
в "гуманистическом" представлении.
#+begin_src sh
ialias df='df -h'
ialias du='du -h'
#+end_src

#+begin_src sh
if (( $+commands[exa] )); then
  # -F / --classify
  # --no-user
  # --no-time
  # --icons
  # --color=always
  alias ls='exa -F --group-directories-first'
  alias ll='exa -lF --group-directories-first --git'
else
  alias ls='ls --color=auto --group-directories-first'
fi
#+end_src

Use neovim for vim if present.
#+begin_src sh
if (( $+commands[nvim] )); then
  ialias vim="nvim"
  ialias vimdiff="nvim -d"
  ialias neovide="neovide --multiGrid --geometry=340x120"
fi
#+end_src

In Debian and its derivatives in package =fd-find= the executable
and the associated manpage were renamed from =fd= to =fdfind=.
#+begin_src sh
if [[ $(grep -Es '^ID_LIKE=.*(?:ubuntu|debian)' /etc/os-release) ]]; then
  ialias fd=fdfind
fi
#+end_src

Git
#+begin_src sh
alias gs='git status'
alias gss='git status -s'
alias gc='git checkout'
alias gd='git diff'
alias gg='git graph'
alias -g random='-m curl -s http://whatthecommit.com/index.txt'
#+end_src

Filesystem aliases
#+begin_src sh
alias ..=' cd ..'
alias ...=' cd ../..'
alias ....=' cd ../../..'
alias .....=' cd ../../../..'
#+end_src

Создание каталогов без коррекции и со всеми родительскими каталогами, если они
отсутствуют.
#+begin_src sh
ialias mkdir='nocorrect mkdir -vp'
#+end_src

#+begin_src sh
ialias mv='nocorrect mv -v'
ialias cp='nocorrect cp -vR'  # рекурсивное копирование
ialias rm='nocorrect rm -v'
#+end_src

#+begin_src sh
ialias grep='grep --color=auto'
ialias wget='wget -c'  # автоматическое продолжение при разрыве соединения
#+end_src

#+begin_src sh
ialias :q='exit'
ialias :Q='exit'
#+end_src

#+begin_src sh
# ialias vifm="vifmcd"
#+end_src

** Footer
#+begin_src sh
unset my_zsh_functions

# vim: tw=75 ts=2 sw=2 fdm=marker
#+end_src

* zlogin
:PROPERTIES:
:header-args: :tangle (file-name-concat (getenv "ZDOTDIR") ".zlogin")
:END:
** Description

*Read at login*

This file is like =.zprofile=, but is read after =.zshrc=. You can consider the
shell to be fully set up at =.zlogin= execution time. This is not the file to
define aliases, functions, shell options, and key bindings. It should not change
the shell environment. It is usually used for messages such as [[http://en.wikipedia.org/wiki/Fortune_(Unix)][fortune]], [[http://www.manpagez.com/man/1/msgs][msgs]], or
for the creation of files.

So, I use it to launch external commands which do not modify shell behaviors
(e.g. a login manager).

** Preamble
#+begin_src sh
#!/usr/bin/env zsh
#
#             ███                 ██
#            ░░██                ░░
#      ██████ ░██  █████   ██████ ██ ██████
#     ░░░░██  ░██ ██░░░██ ██░░░██░██░██░░░██
#        ██   ░██░██  ░██░██  ░██░██░██  ░██
#       ██    ░██░██  ░██░░██████░██░██  ░██
#  ██  ██████ ░██░░█████  ░░░░░██░██░██  ░██
# ░░  ░░░░░░  ░░  ░░░░░    █████ ░░ ░░   ░░
#                         ░░░░░
# This file was automatically generated by Emacs Org-Mode `org-babel-tangle'.
# Do not change this file. The main file is `README.org`.
#+end_src

** Code
Execute code in the background to not affect the current session:
#+begin_src sh
{
  setopt LOCAL_OPTIONS EXTENDED_GLOB GLOB_DOTS
  autoload -U zrecompile

  array=(zprofile zshrc zlogin)
  for i in $array; do
    zrecompile -pq "${ZDOTDIR:-${HOME}}/.$i"
  done

  # Recompile all zsh or sh files.
  # for FILE in {$ZDOTDIR/**,$HOME/.cache/zsh/**}/*.*sh(#qN)
  if [[ -d ${ZDOTDIR} ]]; then
    for FILE in ${ZDOTDIR}/**/*.*sh(#qN); do
      zrecompile -pq $FILE
    done

    # Compile all functions in the single 'digest' file.
    zrecompile -pq "${ZDOTDIR}/functions.zwc" \
               $(echo -n $(find "${ZDOTDIR}"/functions/ -maxdepth 1 -type f))
  fi

  if [[ -d $ZSH[cache] ]]; then
    for FILE in $ZSH[cache]/**/*.*sh(#qN); do
      zrecompile -pq $FILE
    done
  fi

  # Delete all "*.zwc.old" files
  # (#qN) is glob qualifier which sets the NULL_GLOB option for the current
  # pattern, so it doesn't show message if no matches found.
  # for FILE in {$ZDOTDIR/**,$HOME/.cache/zsh/**}/*.zwc.old(#qN);
  for FILE in {${ZDOTDIR}/**,$ZSH[cache]/**}/*.zwc.old(#qN); do
    rm -f -- "$FILE"
  done

} &!
#+end_src

#+begin_src sh
# vim: ts=2 sw=2
#+end_src

* zlogout

*Read at logout, within login shell*

Here, you can clear your terminal or any other resource which was setup at
login.
